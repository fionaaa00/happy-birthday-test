<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ğŸ„ Happy Birthday</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#050807;font-family:ui-sans-serif,system-ui,-apple-system,"PingFang SC","Microsoft YaHei";}
    #app{position:fixed;inset:0}
    #ui{
      position:fixed;left:18px;top:18px;z-index:10;color:#e9e3d0;
      width:min(440px,calc(100vw - 36px));
      background:linear-gradient(180deg, rgba(10,16,12,.65), rgba(6,8,7,.35));
      border:1px solid rgba(200,170,90,.25);
      backdrop-filter: blur(10px);
      border-radius:18px;
      padding:14px 14px 12px;
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
    }
    #ui h1{margin:0 0 6px;font-size:16px;letter-spacing:.4px}
    #ui .sub{opacity:.82;font-size:12px;line-height:1.35}
    #row{display:flex;gap:10px;align-items:center;margin-top:10px;flex-wrap:wrap}
    .btn{
      cursor:pointer;user-select:none;
      border-radius:999px;
      padding:9px 12px;
      border:1px solid rgba(200,170,90,.32);
      background:rgba(12,18,14,.55);
      color:#f0ead7;
      font-size:12px;
    }
    .btn:hover{background:rgba(18,26,20,.65)}
    #file{display:none}
    #badge{
      margin-left:auto;
      display:flex;align-items:center;gap:8px;
      font-size:12px;opacity:.8
    }
    .dot{width:8px;height:8px;border-radius:50%;background:#b91c1c;box-shadow:0 0 12px rgba(255,80,80,.65)}
    .dot.on{background:#16a34a;box-shadow:0 0 12px rgba(60,255,160,.55)}
    #hint{
      margin-top:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(0,0,0,.22);
      font-size:12px;
      line-height:1.45;
      color:#efe9d7;
    }
    #hint b{color:#f7d77a}
    #credit{
      margin-top:10px;opacity:.65;font-size:11px;
      display:flex;gap:10px;flex-wrap:wrap
    }
    #video{
      position:fixed;right:18px;bottom:18px;z-index:10;
      width:220px;height:160px;object-fit:cover;
      border-radius:16px;
      border:1px solid rgba(200,170,90,.22);
      box-shadow:0 18px 60px rgba(0,0,0,.45);
      opacity:.0;pointer-events:none;
      filter:saturate(1.1) contrast(1.05);
    }
    #video.show{opacity:.85}
    @media (max-width: 720px){
      #video{width:160px;height:120px}
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="ui">
    <h1>ğŸ ç»™ <span id="name">TA</span> çš„ç”Ÿæ—¥ç¥ç¦ Â· æ‰‹åŠ¿æ§åˆ¶ 3D åœ£è¯æ ‘</h1>
    <div class="sub">
      å“‘å…‰ç»¿ + é‡‘å±é‡‘ + åœ£è¯çº¢ï¼Œç”µå½±æ„Ÿè¾‰å…‰ä¸å…‰æ™•ã€‚ä¸Šä¼ ç…§ç‰‡ä¼šå˜æˆæ¼‚æµ®â€œç…§ç‰‡äº‘â€ã€‚
      <br/>æ‰‹åŠ¿ï¼š<b>æ¡æ‹³</b>åˆæ‹¢ / <b>å¼ å¼€</b>æ•£å¼€ / <b>æåˆ</b>æŠ“å–ç…§ç‰‡æ”¾å¤§ / <b>ç§»åŠ¨æ‰‹</b>æ—‹è½¬è§†è§’
    </div>

    <div id="row">
      <label class="btn" for="file">ğŸ“· ä¸Šä¼ ç…§ç‰‡</label>
      <input id="file" type="file" accept="image/*" multiple />
      <button class="btn" id="toggleCam">ğŸ“¹ å¼€å¯æ‰‹åŠ¿</button>
      <button class="btn" id="reset">â†©ï¸ é‡ç½®è§†è§’</button>
      <div id="badge"><span class="dot" id="camDot"></span><span id="camTxt">æ‰‹åŠ¿æœªå¼€å¯</span></div>
    </div>

    <div id="hint">
      <b>ç¥ç¦æ–‡æ¡ˆ</b>ï¼š<span id="wish">ç”Ÿæ—¥å¿«ä¹ï¼æ„¿ä½ è¢«æ¸©æŸ”ä¸å¥½è¿å›´ç»•ï¼Œæ–°çš„è¿™ä¸€å²é—ªé—ªå‘å…‰âœ¨</span>
      <br/><span style="opacity:.8">ä½ å¯ä»¥åœ¨æ–‡ä»¶é‡Œæœç´¢ <code>WISH_TEXT</code> æ”¹æˆä½ æƒ³è¯´çš„è¯ã€‚</span>
    </div>

    <div id="credit">
      <span>THREE.js + WebGL + Instancing + GLSL</span>
      <span>MediaPipe Hands</span>
      <span>Bloom / Filmic Tone</span>
    </div>
  </div>

  <video id="video" playsinline></video>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { EffectComposer } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js";

    // =========================
    // ä½ æƒ³è‡ªå®šä¹‰çš„ç¥ç¦æ–‡å­—ï¼š
    // =========================
    const WISH_TEXT = "ç”Ÿæ—¥å¿«ä¹ï¼æ„¿ä½ è¢«æ¸©æŸ”ä¸å¥½è¿å›´ç»•ï¼Œæ–°çš„è¿™ä¸€å²é—ªé—ªå‘å…‰âœ¨";
    document.getElementById("wish").textContent = WISH_TEXT;

    // URL å‚æ•°æ”¯æŒï¼š?name=xxx
    const params = new URLSearchParams(location.search);
    const who = params.get("name");
    if (who) document.getElementById("name").textContent = decodeURIComponent(who);

    const app = document.getElementById("app");
    const videoEl = document.getElementById("video");

    // ---------- é¢œè‰²ä½“ç³»ï¼ˆå“‘å…‰ç»¿ / é‡‘å±é‡‘ / åœ£è¯çº¢ï¼‰ ----------
    const COLORS = {
      matteGreen: new THREE.Color("#0d3b2a"),
      metallicGold: new THREE.Color("#d2b45b"),
      christmasRed: new THREE.Color("#b11226"),
      warmGlow: new THREE.Color("#ffd9a6"),
      bg: new THREE.Color("#050807")
    };

    // ---------- Renderer / Scene / Camera ----------
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.08;
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = COLORS.bg;

    const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 200);
    camera.position.set(0, 1.6, 7.8);

    // ---------- Postprocessing: Bloomï¼ˆç”µå½±æ„Ÿè¾‰å…‰ï¼‰ ----------
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.25, 0.85, 0.15);
    composer.addPass(bloom);

    // ---------- Lights ----------
    const key = new THREE.DirectionalLight(COLORS.warmGlow, 2.2);
    key.position.set(4, 6, 4);
    scene.add(key);

    const fill = new THREE.DirectionalLight(new THREE.Color("#a7ffdf"), 0.65);
    fill.position.set(-4, 2, 2);
    scene.add(fill);

    const rim = new THREE.PointLight(new THREE.Color("#ff9db2"), 1.1, 30);
    rim.position.set(0, 5.5, -6);
    scene.add(rim);

    const ambient = new THREE.AmbientLight(new THREE.Color("#a28f64"), 0.35);
    scene.add(ambient);

    // ---------- Floor subtle haze ----------
    const floorGeo = new THREE.PlaneGeometry(60, 60);
    const floorMat = new THREE.MeshStandardMaterial({
      color: new THREE.Color("#070a09"),
      metalness: 0.2,
      roughness: 0.9
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -2.2;
    scene.add(floor);

    // ---------- A soft volumetric-ish halo (shader billboard) ----------
    const haloGeo = new THREE.PlaneGeometry(12, 12);
    const haloMat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      uniforms: {
        uColor: { value: new THREE.Color("#ffd8a8") },
        uTime: { value: 0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          vec4 mv = modelViewMatrix * vec4(position,1.0);
          gl_Position = projectionMatrix * mv;
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        uniform vec3 uColor;
        uniform float uTime;
        float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
        void main(){
          vec2 uv = vUv * 2.0 - 1.0;
          float r = length(uv);
          float glow = exp(-r*r*2.2);
          float flick = 0.85 + 0.15*hash(uv + uTime*0.1);
          vec3 col = uColor * glow * flick;
          float a = glow * 0.26;
          gl_FragColor = vec4(col, a);
        }
      `
    });
    const halo = new THREE.Mesh(haloGeo, haloMat);
    halo.position.set(0, 1.6, -2.5);
    scene.add(halo);

    // ---------- Instanced ornaments (balls / cubes / candy canes) ----------
    const ORN_COUNT = 520;
    const CUBE_COUNT = 220;
    const CANE_COUNT = 120;

    function makeInstanced(geo, mat, count){
      const mesh = new THREE.InstancedMesh(geo, mat, count);
      mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      scene.add(mesh);
      return mesh;
    }

    const ballGeo = new THREE.SphereGeometry(0.08, 18, 18);
    const ballMat = new THREE.MeshStandardMaterial({
      color: COLORS.metallicGold,
      metalness: 0.95,
      roughness: 0.28,
      emissive: new THREE.Color("#241a07"),
      emissiveIntensity: 0.35
    });
    const balls = makeInstanced(ballGeo, ballMat, ORN_COUNT);

    const cubeGeo = new THREE.BoxGeometry(0.11, 0.11, 0.11);
    const cubeMat = new THREE.MeshStandardMaterial({
      color: COLORS.christmasRed,
      metalness: 0.45,
      roughness: 0.55,
      emissive: new THREE.Color("#24020a"),
      emissiveIntensity: 0.28
    });
    const cubes = makeInstanced(cubeGeo, cubeMat, CUBE_COUNT);

    // Candy cane = small cylinder + hook illusion (two cylinders grouped inside instancing by stretching)
    const caneGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.38, 14, 1);
    const caneMat = new THREE.MeshStandardMaterial({
      color: new THREE.Color("#f2efe9"),
      metalness: 0.15,
      roughness: 0.65,
      emissive: new THREE.Color("#0a0a0a"),
      emissiveIntensity: 0.0
    });
    const canes = makeInstanced(caneGeo, caneMat, CANE_COUNT);

    // ---------- Photo cloud (planes) ----------
    const MAX_PHOTOS = 28;
    const photoGroup = new THREE.Group();
    scene.add(photoGroup);

    const photoPlanes = [];
    const photoTargets = [];
    const photoTextures = [];
    const photoRayTargets = []; // for grabbing
    const texLoader = new THREE.TextureLoader();

    function createPhotoPlane(tex){
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();

      const mat = new THREE.MeshStandardMaterial({
        map: tex,
        metalness: 0.1,
        roughness: 0.65,
        emissive: new THREE.Color("#1b1408"),
        emissiveIntensity: 0.28
      });

      const aspect = (tex.image?.width && tex.image?.height) ? (tex.image.width/tex.image.height) : 1.0;
      const w = 0.65;
      const h = w / aspect;
      const geo = new THREE.PlaneGeometry(w, h);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = false;
      mesh.receiveShadow = false;
      mesh.userData.isPhoto = true;

      photoGroup.add(mesh);
      photoPlanes.push(mesh);
      photoRayTargets.push(mesh);

      // åˆå§‹/ç›®æ ‡ï¼ˆåé¢çŠ¶æ€ä¼šé©±åŠ¨ï¼‰
      photoTargets.push({
        pos: new THREE.Vector3(),
        rot: new THREE.Euler(),
        scale: new THREE.Vector3(1,1,1)
      });
      return mesh;
    }

    // ---------- Tree â€œstatesâ€ ----------
    const State = { CONE: "cone", SCATTER: "scatter", FOCUS: "focus" };
    let currentState = State.CONE;
    let targetState = State.CONE;

    let focusedPhoto = null;

    // Smooth transition helper
    function damp(current, target, lambda, dt){
      return THREE.MathUtils.damp(current, target, lambda, dt);
    }
    function dampVec3(v, target, lambda, dt){
      v.x = damp(v.x, target.x, lambda, dt);
      v.y = damp(v.y, target.y, lambda, dt);
      v.z = damp(v.z, target.z, lambda, dt);
    }

    // ---------- Layout: cone positions for ornaments ----------
    const ballHome = new Array(ORN_COUNT);
    const cubeHome = new Array(CUBE_COUNT);
    const caneHome = new Array(CANE_COUNT);

    const ballScatter = new Array(ORN_COUNT);
    const cubeScatter = new Array(CUBE_COUNT);
    const caneScatter = new Array(CANE_COUNT);

    const tmpObj = new THREE.Object3D();

    function randInCone(){
      // Cone around y axis, height ~4.2
      const h = 4.2;
      const y = Math.random() * h - 1.9; // shift down a bit
      const t = (y + 1.9) / h; // 0..1
      const r = (1.7 * (1.0 - t)) * (0.25 + 0.75*Math.random());
      const a = Math.random() * Math.PI * 2;
      return new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r);
    }
    function randInSphere(radius=5.5){
      const u = Math.random();
      const v = Math.random();
      const theta = u * 2*Math.PI;
      const phi = Math.acos(2*v - 1);
      const r = radius * Math.cbrt(Math.random());
      return new THREE.Vector3(
        r * Math.sin(phi) * Math.cos(theta),
        r * Math.cos(phi) * 0.55 + 0.6,     // keep it more centered vertically
        r * Math.sin(phi) * Math.sin(theta)
      );
    }

    function initLayouts(){
      for(let i=0;i<ORN_COUNT;i++){
        ballHome[i] = randInCone();
        ballScatter[i] = randInSphere(6.2);
      }
      for(let i=0;i<CUBE_COUNT;i++){
        cubeHome[i] = randInCone();
        cubeScatter[i] = randInSphere(6.0);
      }
      for(let i=0;i<CANE_COUNT;i++){
        caneHome[i] = randInCone();
        caneScatter[i] = randInSphere(5.4);
      }

      // photo targets too
      for(let i=0;i<photoTargets.length;i++){
        photoTargets[i].pos.copy(randInCone());
      }
    }
    initLayouts();

    // ---------- Build a simple â€œstarâ€ topper ----------
    const starGeo = new THREE.IcosahedronGeometry(0.18, 0);
    const starMat = new THREE.MeshStandardMaterial({
      color: new THREE.Color("#f9e6a6"),
      metalness: 1.0,
      roughness: 0.18,
      emissive: new THREE.Color("#7a4f12"),
      emissiveIntensity: 0.55
    });
    const star = new THREE.Mesh(starGeo, starMat);
    star.position.set(0, 2.35, 0);
    scene.add(star);

    // ---------- Floating dust particles (shader points) ----------
    const dustCount = 2400;
    const dustGeo = new THREE.BufferGeometry();
    const dustPos = new Float32Array(dustCount*3);
    const dustSeed = new Float32Array(dustCount);
    for(let i=0;i<dustCount;i++){
      const p = randInSphere(12.0);
      dustPos[i*3+0]=p.x; dustPos[i*3+1]=p.y+0.2; dustPos[i*3+2]=p.z;
      dustSeed[i]=Math.random()*1000;
    }
    dustGeo.setAttribute("position", new THREE.BufferAttribute(dustPos, 3));
    dustGeo.setAttribute("aSeed", new THREE.BufferAttribute(dustSeed, 1));

    const dustMat = new THREE.ShaderMaterial({
      transparent:true,
      depthWrite:false,
      blending:THREE.AdditiveBlending,
      uniforms:{
        uTime:{value:0},
        uSize:{value:2.2},
      },
      vertexShader:`
        uniform float uTime;
        uniform float uSize;
        attribute float aSeed;
        varying float vA;
        void main(){
          vec3 p = position;
          float t = uTime*0.12 + aSeed;
          p.x += sin(t)*0.08;
          p.y += cos(t*1.2)*0.08;
          p.z += sin(t*0.9)*0.08;
          vec4 mv = modelViewMatrix * vec4(p,1.0);
          gl_Position = projectionMatrix * mv;
          float dist = length(mv.xyz);
          gl_PointSize = uSize * (1.0 / max(dist*0.18, 0.5));
          vA = 0.65 + 0.35*sin(t*0.7);
        }
      `,
      fragmentShader:`
        varying float vA;
        void main(){
          vec2 uv = gl_PointCoord*2.0-1.0;
          float r = dot(uv,uv);
          float a = exp(-r*3.2)*vA;
          gl_FragColor = vec4(1.0, 0.88, 0.62, a*0.38);
        }
      `
    });
    const dust = new THREE.Points(dustGeo, dustMat);
    scene.add(dust);

    // ---------- Camera control variables (gesture-driven) ----------
    const camTarget = {
      yaw: 0,
      pitch: 0.06,
      radius: 7.8,
      center: new THREE.Vector3(0, 1.2, 0)
    };
    let camState = { yaw: 0, pitch: 0.06, radius: 7.8 };
    function applyCamera(dt){
      camState.yaw = damp(camState.yaw, camTarget.yaw, 7.5, dt);
      camState.pitch = damp(camState.pitch, camTarget.pitch, 7.5, dt);
      camState.radius = damp(camState.radius, camTarget.radius, 7.5, dt);

      const cp = Math.cos(camState.pitch), sp = Math.sin(camState.pitch);
      const cy = Math.cos(camState.yaw), sy = Math.sin(camState.yaw);
      camera.position.set(
        camTarget.center.x + camState.radius * sy * cp,
        camTarget.center.y + camState.radius * sp,
        camTarget.center.z + camState.radius * cy * cp
      );
      camera.lookAt(camTarget.center);
    }

    // ---------- Wish text as 3D (simple canvas texture) ----------
    function makeTextSprite(text){
      const canvas = document.createElement("canvas");
      canvas.width = 1024;
      canvas.height = 256;
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // background glow strip
      const g = ctx.createLinearGradient(0,0,1024,0);
      g.addColorStop(0, "rgba(210,180,91,0.0)");
      g.addColorStop(.2, "rgba(210,180,91,0.14)");
      g.addColorStop(.5, "rgba(255,216,168,0.22)");
      g.addColorStop(.8, "rgba(210,180,91,0.14)");
      g.addColorStop(1, "rgba(210,180,91,0.0)");
      ctx.fillStyle = g;
      ctx.fillRect(0, 70, 1024, 116);

      ctx.font = "600 64px ui-sans-serif, system-ui, -apple-system, PingFang SC, Microsoft YaHei";
      ctx.textAlign = "center";
      ctx.fillStyle = "rgba(247, 231, 187, 0.95)";
      ctx.shadowColor = "rgba(255, 220, 155, 0.65)";
      ctx.shadowBlur = 22;
      ctx.fillText(text, 512, 150);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, depthWrite:false });
      const geo = new THREE.PlaneGeometry(5.8, 1.45);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(0, 3.05, -0.9);
      return mesh;
    }
    const textBanner = makeTextSprite(WISH_TEXT);
    scene.add(textBanner);

    // ---------- State switching ----------
    function goState(next){
      targetState = next;
      if (next !== State.FOCUS) focusedPhoto = null;
      if (next === State.CONE) camTarget.radius = 7.8;
      if (next === State.SCATTER) camTarget.radius = 8.6;
    }

    // ---------- Update instanced transforms according to state ----------
    const ballPos = new Array(ORN_COUNT).fill(0).map(()=>new THREE.Vector3());
    const cubePos = new Array(CUBE_COUNT).fill(0).map(()=>new THREE.Vector3());
    const canePos = new Array(CANE_COUNT).fill(0).map(()=>new THREE.Vector3());

    // initialize at cone
    for(let i=0;i<ORN_COUNT;i++) ballPos[i].copy(ballHome[i]);
    for(let i=0;i<CUBE_COUNT;i++) cubePos[i].copy(cubeHome[i]);
    for(let i=0;i<CANE_COUNT;i++) canePos[i].copy(caneHome[i]);

    function updateInstanced(mesh, positions, kind, dt){
      for(let i=0;i<positions.length;i++){
        const p = positions[i];
        // subtle float
        const w = 0.35 + 0.65*Math.sin((time*0.8) + i*0.17);
        const floatY = 0.02*w;

        tmpObj.position.set(p.x, p.y + floatY, p.z);
        if (kind === "ball"){
          tmpObj.scale.setScalar(1.0);
          tmpObj.rotation.set(0, time*0.25 + i*0.02, 0);
        } else if (kind === "cube"){
          tmpObj.scale.setScalar(1.0);
          tmpObj.rotation.set(time*0.35 + i*0.03, time*0.28 + i*0.01, 0);
        } else { // cane
          tmpObj.scale.set(1.0, 1.0, 1.0);
          tmpObj.rotation.set(0.2 + Math.sin(time+i)*0.2, time*0.22 + i*0.01, 0.4);
        }
        tmpObj.updateMatrix();
        mesh.setMatrixAt(i, tmpObj.matrix);
      }
      mesh.instanceMatrix.needsUpdate = true;
    }

    function updateTargets(dt){
      // determine lerp target arrays
      const coneT = (targetState === State.CONE);
      const scatterT = (targetState === State.SCATTER || targetState === State.FOCUS);

      for(let i=0;i<ORN_COUNT;i++){
        const t = coneT ? ballHome[i] : ballScatter[i];
        dampVec3(ballPos[i], t, 3.6, dt);
      }
      for(let i=0;i<CUBE_COUNT;i++){
        const t = coneT ? cubeHome[i] : cubeScatter[i];
        dampVec3(cubePos[i], t, 3.6, dt);
      }
      for(let i=0;i<CANE_COUNT;i++){
        const t = coneT ? caneHome[i] : caneScatter[i];
        dampVec3(canePos[i], t, 3.6, dt);
      }

      // photo positions
      for(let i=0;i<photoPlanes.length;i++){
        const mesh = photoPlanes[i];
        if (!mesh) continue;

        // cone vs scatter target
        const base = coneT ? randInCone() : randInSphere(5.8);
        const tgt = photoTargets[i];
        // update target slowly so it feels organic
        tgt.pos.lerp(base, 0.04);

        if (targetState === State.FOCUS && focusedPhoto === mesh){
          // bring to front
          const front = new THREE.Vector3(0, 1.45, 2.2);
          tgt.pos.lerp(front, 0.35);
          tgt.scale.lerp(new THREE.Vector3(2.7,2.7,2.7), 0.28);
          tgt.rot.x = damp(tgt.rot.x, 0, 7.5, dt);
          tgt.rot.y = damp(tgt.rot.y, 0, 7.5, dt);
          tgt.rot.z = damp(tgt.rot.z, 0, 7.5, dt);
        } else {
          tgt.scale.lerp(new THREE.Vector3(1,1,1), 0.08);
          tgt.rot.x = damp(tgt.rot.x, 0.06*Math.sin(time*0.7+i), 3.0, dt);
          tgt.rot.y = damp(tgt.rot.y, 0.35*Math.sin(time*0.5+i*0.2), 3.0, dt);
          tgt.rot.z = damp(tgt.rot.z, 0.12*Math.sin(time*0.6+i*0.3), 3.0, dt);
        }

        // apply to mesh smoothly
        dampVec3(mesh.position, tgt.pos, 4.0, dt);
        mesh.rotation.x = damp(mesh.rotation.x, tgt.rot.x, 4.0, dt);
        mesh.rotation.y = damp(mesh.rotation.y, tgt.rot.y, 4.0, dt);
        mesh.rotation.z = damp(mesh.rotation.z, tgt.rot.z, 4.0, dt);
        mesh.scale.x = damp(mesh.scale.x, tgt.scale.x, 5.2, dt);
        mesh.scale.y = damp(mesh.scale.y, tgt.scale.y, 5.2, dt);
        mesh.scale.z = damp(mesh.scale.z, tgt.scale.z, 5.2, dt);
      }

      // star + halo
      star.position.y = damp(star.position.y, targetState===State.CONE ? 2.35 : 2.05, 3.8, dt);
      halo.position.y = damp(halo.position.y, targetState===State.CONE ? 1.6 : 1.2, 3.4, dt);
    }

    // ---------- Photo grabbing via 3D ray (gesture -> screen coord) ----------
    const raycaster = new THREE.Raycaster();
    function pickPhotoFromNDC(xNdc, yNdc){
      raycaster.setFromCamera({x:xNdc, y:yNdc}, camera);
      const hits = raycaster.intersectObjects(photoRayTargets, false);
      if (hits.length) return hits[0].object;
      return null;
    }

    // ---------- UI buttons ----------
    const toggleCamBtn = document.getElementById("toggleCam");
    const camDot = document.getElementById("camDot");
    const camTxt = document.getElementById("camTxt");

    document.getElementById("reset").addEventListener("click", ()=>{
      camTarget.yaw = 0; camTarget.pitch = 0.06; camTarget.radius = (targetState===State.CONE?7.8:8.6);
    });
    document.getElementById("file").addEventListener("change", async (e)=>{
      const files = [...(e.target.files||[])].slice(0, MAX_PHOTOS);
      for (const f of files){
        const url = URL.createObjectURL(f);
        await new Promise((resolve)=>{
          texLoader.load(url, (tex)=>{
            photoTextures.push(tex);
            createPhotoPlane(tex);
            resolve();
          });
        });
      }
      // refresh targets array length
      while (photoTargets.length < photoPlanes.length){
        photoTargets.push({pos:new THREE.Vector3(), rot:new THREE.Euler(), scale:new THREE.Vector3(1,1,1)});
      }
      // Give photos initial scatter targets if already in scatter
      if (targetState !== State.CONE){
        for(let i=0;i<photoTargets.length;i++){
          photoTargets[i].pos.copy(randInSphere(5.8));
        }
      }
    });

    // ---------- MediaPipe Hands (CDN) ----------
    let hands = null;
    let cameraFeed = null;
    let handEnabled = false;

    // Gesture detection state
    let lastHand = null;
    let pinch = { on:false, strength:0, xNdc:0, yNdc:0 };
    let palmOpen = false;
    let fist = false;

    function dist(a,b){
      const dx=a.x-b.x, dy=a.y-b.y, dz=(a.z||0)-(b.z||0);
      return Math.sqrt(dx*dx+dy*dy+dz*dz);
    }

    function computeGestures(landmarks){
      // landmarks: 21 points
      // Simple heuristics:
      // - pinch: thumb tip (4) near index tip (8)
      // - open palm: finger tips far from palm center, and fingers extended (tip farther than pip)
      // - fist: tips near palm, folded
      const wrist = landmarks[0];
      const palm = landmarks[9]; // approx center
      const thumbTip = landmarks[4];
      const indexTip = landmarks[8];
      const middleTip = landmarks[12];
      const ringTip = landmarks[16];
      const pinkyTip = landmarks[20];

      const indexPip = landmarks[6], middlePip = landmarks[10], ringPip = landmarks[14], pinkyPip = landmarks[18];

      const pinchD = dist(thumbTip, indexTip);
      const palmScale = dist(wrist, landmarks[9]) + 1e-6;
      const pinchStrength = THREE.MathUtils.clamp(1.0 - (pinchD/(palmScale*0.55)), 0, 1);

      const fExt =
        (dist(indexTip,palm) > dist(indexPip,palm)) +
        (dist(middleTip,palm) > dist(middlePip,palm)) +
        (dist(ringTip,palm) > dist(ringPip,palm)) +
        (dist(pinkyTip,palm) > dist(pinkyPip,palm));

      const tipsNearPalm =
        (dist(indexTip,palm) < palmScale*0.8) +
        (dist(middleTip,palm) < palmScale*0.8) +
        (dist(ringTip,palm) < palmScale*0.8) +
        (dist(pinkyTip,palm) < palmScale*0.8);

      const isOpen = fExt >= 3 && pinchStrength < 0.75;
      const isFist = tipsNearPalm >= 3 && pinchStrength < 0.65;

      // hand movement for camera rotation: use palm point in normalized video coords
      const px = palm.x; // 0..1
      const py = palm.y; // 0..1

      return {
        pinchStrength,
        isPinch: pinchStrength > 0.78,
        isOpen,
        isFist,
        palmX: px,
        palmY: py,
      };
    }

    async function enableHands(){
      // Load mediapipe scripts dynamically
      const { Hands } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js");
      const { Camera } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js");

      hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });
      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
      });

      hands.onResults((results)=>{
        if (!results.multiHandLandmarks || !results.multiHandLandmarks.length){
          lastHand = null;
          pinch.on = false; pinch.strength = 0;
          palmOpen = false; fist = false;
          return;
        }
        const lm = results.multiHandLandmarks[0];
        lastHand = lm;

        const g = computeGestures(lm);
        pinch.strength = g.pinchStrength;
        pinch.on = g.isPinch;

        palmOpen = g.isOpen;
        fist = g.isFist;

        // Convert palm coord to NDC for picking:
        // MediaPipe gives x,y in [0,1] with origin top-left in image.
        pinch.xNdc = (g.palmX * 2 - 1);
        pinch.yNdc = -(g.palmY * 2 - 1);

        // Camera rotation when in scatter/focus:
        if (targetState !== State.CONE){
          // Move hand to rotate: map palm X/Y to yaw/pitch target
          const yaw = (g.palmX - 0.5) * 2.4;     // ~[-1.2,1.2]
          const pitch = (0.55 - g.palmY) * 1.0;  // up/down
          camTarget.yaw = THREE.MathUtils.clamp(yaw, -1.35, 1.35);
          camTarget.pitch = THREE.MathUtils.clamp(pitch, -0.12, 0.55);
        }
      });

      // webcam
      videoEl.classList.add("show");
      cameraFeed = new Camera(videoEl, {
        onFrame: async () => { await hands.send({ image: videoEl }); },
        width: 640,
        height: 480
      });
      cameraFeed.start();

      handEnabled = true;
      camDot.classList.add("on");
      camTxt.textContent = "æ‰‹åŠ¿å·²å¼€å¯";
      toggleCamBtn.textContent = "ğŸ›‘ å…³é—­æ‰‹åŠ¿";
    }

    async function disableHands(){
      handEnabled = false;
      if (cameraFeed) cameraFeed.stop();
      cameraFeed = null;
      hands = null;
      videoEl.classList.remove("show");
      camDot.classList.remove("on");
      camTxt.textContent = "æ‰‹åŠ¿æœªå¼€å¯";
      toggleCamBtn.textContent = "ğŸ“¹ å¼€å¯æ‰‹åŠ¿";
    }

    toggleCamBtn.addEventListener("click", async ()=>{
      try{
        if (!handEnabled) await enableHands();
        else await disableHands();
      }catch(err){
        console.error(err);
        alert("å¼€å¯æ‰‹åŠ¿å¤±è´¥ï¼šéœ€è¦ HTTPS æˆ–æµè§ˆå™¨å…è®¸æ‘„åƒå¤´æƒé™ã€‚ä½ ä¹Ÿå¯ä»¥å…ˆç”¨æŒ‰é’®+ä¸Šä¼ ç…§ç‰‡ä½“éªŒã€‚");
      }
    });

    // ---------- Hand-driven state machine ----------
    let lastSwitchT = 0;
    function maybeSwitchByGesture(now){
      const coolDown = 650; // ms
      if (now - lastSwitchT < coolDown) return;

      if (fist){
        goState(State.CONE);
        lastSwitchT = now;
        return;
      }
      if (palmOpen){
        goState(State.SCATTER);
        lastSwitchT = now;
        return;
      }
      if (pinch.on && targetState !== State.CONE){
        // try grabbing a photo
        const picked = pickPhotoFromNDC(pinch.xNdc, pinch.yNdc);
        if (picked){
          focusedPhoto = picked;
          goState(State.FOCUS);
          lastSwitchT = now;
        }
      }
      // exit focus back to scatter by strong open palm
      if (targetState === State.FOCUS && palmOpen){
        goState(State.SCATTER);
        lastSwitchT = now;
      }
    }

    // ---------- Resize ----------
    addEventListener("resize", ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);
      bloom.setSize(innerWidth, innerHeight);
    });

    // ---------- Animate ----------
    let time = 0;
    let last = performance.now();
    function tick(now){
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;
      time += dt;

      // subtle bloom breathing
      bloom.strength = 1.18 + 0.18*Math.sin(time*0.55);
      haloMat.uniforms.uTime.value = time;
      dustMat.uniforms.uTime.value = time;

      // gesture-based state changes
      if (handEnabled) maybeSwitchByGesture(now);

      // update targets and instances
      updateTargets(dt);

      updateInstanced(balls, ballPos, "ball", dt);
      updateInstanced(cubes, cubePos, "cube", dt);
      updateInstanced(canes, canePos, "cane", dt);

      // keep text banner gently breathing
      textBanner.position.y = 3.05 + Math.sin(time*0.8)*0.03;
      textBanner.material.opacity = 0.92;

      // camera
      applyCamera(dt);

      // render
      composer.render();

      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    // ---------- Default: start in cone, but allow click to scatter for demo ----------
    renderer.domElement.addEventListener("pointerdown", ()=>{
      if (!handEnabled){
        // no camera: clicking cycles states for convenience
        if (targetState === State.CONE) goState(State.SCATTER);
        else if (targetState === State.SCATTER && photoPlanes.length) { focusedPhoto = photoPlanes[0]; goState(State.FOCUS); }
        else goState(State.CONE);
      }
    });
  </script>
</body>
</html>

